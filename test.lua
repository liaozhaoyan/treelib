---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/10/27 1:32 PM
---

package.cpath = package.cpath .. ";./?.so"
package.path = package.path .. ";./?.lua"
local treelib = require("treelib")
local wrap = require("treewrap")
local cjson = require("cjson")
local j = cjson.new()

math.randomseed(os.time())  --pure random

local function create(start)
    start = start or 0
    local tree = treelib.new()
    local n1 = tree:add_child(tree:root(), "hello")
    local n2 = tree:add_child(n1, "world" .. n1 + start)
    n2 = tree:add_child(n1, "world" .. n2 + start)
    n2 = tree:add_child(n1, "world" .. n2 + start)
    n2 = tree:add_child(n1, "world" .. n2 + start)
    n2 = tree:add_child(n1, "world" .. n2 + start)
    local n3 = tree:add_child(n2, "world" .. n2 + start)
    n3 = tree:add_child(n2, "world" .. n3 + start)
    n3 = tree:add_child(n2, "world" .. n3 + start)
    n3 = tree:add_child(n2, "world" .. n3 + start)
    n3 = tree:add_child(n3, "world" .. n3 + start)
    return tree
end

local function DeepCompare(t1, t2)
    if type(t1) ~= "table" or type(t2) ~= "table" then
        return t1 == t2
    end
    for k, v in pairs(t1) do
        if not DeepCompare(t2[k], v) then
            return false
        end
    end
    for k, v in pairs(t2) do
        if not DeepCompare(t1[k], v) then
            return false
        end
    end
    return true
end

local function randChoose(cells, start, remove)
    start = start or 1
    local size = #cells
    local choose = math.random(start, size)
    local ret = cells[choose]
    if remove then
        table.remove(cells, choose)
    end
    return ret
end

local newCell = "new hello."
local tree = create()
wrap.show(tree)
assert(tree:root() == 0)  -- root()
assert(#tree == 12)       -- len
tree[1] = newCell             -- set
assert(tree(1) == newCell)  -- get
assert(tree:depth() == 5)   -- depth
assert(tree:level(10) == 4)  -- level

assert(tree:parent(10) == 6)
assert(tree:parent(11) == 10)
assert(not tree:parent(0))   -- root parent is nil
assert(wrap.contains(tree, 0))
assert(wrap.contains(tree, 6))
assert(not wrap.is_branch(tree, 0))
assert(wrap.is_branch(tree, 6))
local hope = {1, 6, 10, 11, 9, 8, 7, 5, 4, 3, 2}
assert(DeepCompare(wrap.leaves(tree, 1), hope))
assert(wrap.is_ancestor(tree, 0, 6))
assert(wrap.is_ancestor(tree, 1, 11))
assert(not wrap.is_ancestor(tree, 2, 8))
assert(not wrap.is_ancestor(tree, 0, 0))
assert(not wrap.is_ancestor(tree, 1, 0))

local function filter_func(id, level, value)
    if string.sub(value, 1, 5) == "world" then
        return true
    end
    return false
end

hope = {
    [6] = "world5",
    [10] = "world9",
    [11] = "world10",
    [9] = "world8",
    [8] = "world7",
    [5] = "world4",
    [4] = "worl3",
    [3] = "world2",
    [2] = "world1"
}
local cells = wrap.filter_nodes(tree, filter_func) -- filter_nodes
local cnt = 0
for id, value in pairs(cells) do
    cnt = cnt + 1
    assert(filter_func(id, 1, value))
end
assert(cnt == 10)

local cells = wrap.filter_nodes(tree, filter_func, 6) -- filter_nodes
local cnt = 0
for id, value in pairs(cells) do
    cnt = cnt + 1
    assert(filter_func(id, 1, value))
end
assert(cnt == 6)

local size = #tree
local node = wrap.move_node(tree, 11, 2) -- move node
assert(tree:parent(node) == 2)
assert(#tree == size)

-- remove subtree
hope = {6, 5, 4, 3}
assert(DeepCompare(wrap.siblings(tree, 2), hope))  -- check child
hope = {5, 4, 3}
tree:remove_subtree(6)
assert(DeepCompare(wrap.siblings(tree, 2), hope))
assert(not wrap.contains(tree, 6))

-- remove node
tree = create()
tree:remove_node(6)
hope = {5,4,3,10,9,8,7}
assert(DeepCompare(wrap.siblings(tree, 2), hope))
tree:remove_node(4)
hope = {5,3,10,9,8,7}
assert(DeepCompare(wrap.siblings(tree, 2), hope))
tree:remove_node(tree:root())
--tree:remove_node(tree:root())  -- this will cease assert failed.

tree = create()
print("\n sub test")
wrap.show(tree)
local sub = wrap.subtree(tree, 1)
wrap.show(sub)
print("sub test end")

print("\n paste test")
tree = create()
sub = create()
wrap.paste(tree, 6, sub)
wrap.show(tree)
print("paste test end")

os.exit(1)  -- to run rand test, comment this line
print("rand test")
local topCells = 10 * 10000
tree = create()
while true do
    local cells
    while #tree < topCells do
        cells = wrap.leaves(tree)
        local sub = create(tonumber(cells[-1]))
        for i = 1, math.random(300, 500) do
            local choose = randChoose(cells, 1)
            wrap.paste(tree, choose, sub)
        end
        print(#tree)
    end
    print(tree:depth())
    cells = wrap.leaves(tree)
    while #tree > 4 do
        local choose = randChoose(cells, 2, true)
        tree:remove_node(choose)
    end
    print(#tree)
end

--while 1 do
--    create()
--end
