---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/10/28 9:31 AM
---
--- wrapper for treelib.

local m = {}
local treelib = require("treelib")

local function defaultFmt(id, level, value)
    local head = ""
    if level > 0 then
        head = string.rep(" ", (level - 1) * 4) .. " |__"
    end
    local content = string.format("%s(%d):%s", head, id, tostring(value))
    print(content)
end

local function recShow(tree, id, topLevel, fmt)
    for cid, l, v in tree:children(id) do
        fmt(cid, l - topLevel, v)
        recShow(tree, cid, topLevel, fmt)
    end
end

function m.show(tree, id, fmt)
    id = id or tree:root()
    fmt = fmt or defaultFmt
    local topLevel

    topLevel = tree:level(id)

    fmt(id, 0, tree(id))
    recShow(tree, id, topLevel, fmt)
end

local function recContain(tree, upId, id)
    local ret
    for cid, _, _ in tree:children(upId) do
        if (id == cid) then
            return true
        end
        ret = recContain(tree, cid, id)
        if ret then
            return ret
        end
    end
    return false
end

function m.contains(tree, id)
    local rootId = tree:root()
    if rootId == id then
        return true
    end
    return recContain(tree, rootId, id)
end

function m.is_branch(tree, id)
    assert(m.contains(tree, id))
    if id == tree:root() then
        return false
    end
    return true
end

local function recLeaves(tree, id, cells, cnt)
    for cid, _, _ in tree:children(id) do
        cnt = cnt + 1
        cells[cnt] = cid
        cnt = recLeaves(tree, cid, cells, cnt)
    end
    return cnt
end

function m.leaves(tree, id)
    id = id or tree:root()
    local cells = {}
    local cnt = 1
    cells[cnt] = id

    recLeaves(tree, id, cells, cnt)
    return cells
end

function m.is_ancestor(tree, ancestorId, childId)
    local root = tree:root()
    local parent = childId

    while parent ~= root do
        parent = tree:parent(parent)
        if (parent == ancestorId) then
            return true
        end
    end
    return false
end

local function defaultList(id, level, value)
    return {
        id = id,
        level = level,
        value = value,
    }
end

local function recList(tree, cells, id, listFunc)
    local cnt = 0
    local children = {}
    for cid, l, v in tree:children(id) do
        cnt = cnt + 1
        local cell = listFunc(cid, l, v)
        children[cnt] = cell
        recList(tree, cell, cid, listFunc)
    end
    if cnt > 0 then
        cells.children = children
    end
end

function m.toList(tree, id, listFunc)
    id = id or tree:root()
    listFunc = listFunc or defaultList

    local cells
    cells = listFunc(id, tree:level(id), tree(id))
    recList(tree, cells, id, listFunc)
    return cells
end

function m.siblings(tree, id)
    local parent = tree:parent(id)
    local ret = {}
    local cnt = 0

    for cid, _, _ in tree:children(parent) do
        if id ~= cid then
            cnt = cnt + 1
            ret[cnt] = cid
        end
    end
    return ret
end

local function recAppend(tree, id, sub, sub_id)
    for cid, _, value in tree:children(id) do
        local sub_cid = sub:add_child(sub_id, value)
        recAppend(tree, cid, sub, sub_cid)
    end
end

function m.subtree(tree, id)
    local sub = treelib.new(tree(id))
    recAppend(tree, id, sub, sub:root())
    return sub
end

local function recPaste(tree, treeId, child, childId)
    for cid, _, value in child:children(childId) do
        local nid = tree:add_child(treeId, value)
        recPaste(tree, nid, child, cid)
    end
end

function m.paste(tree, id, child)
    assert(m.contains(tree, id), string.format("id %d is not in cell", id))
    local childId = child:root()
    local treeId = tree:add_child(id, child(childId))

    recPaste(tree, treeId, child, childId)
end

local function recFilter(tree, id, filter, cells)
    for cid, level, value in tree:children(id) do
        if (filter(cid, level, value)) then
            cells[cid] = value
        end
        recFilter(tree, cid, filter, cells)
    end
end

function m.filter_nodes(tree, filter, id)
    local cells = {}
    id = id or tree:root()
    local value = tree(id)
    if filter(id, tree:level(id), tree(id)) then
        cells[id] = value
    end

    recFilter(tree, id, filter, cells)
    return cells
end

function m.move_node(tree, id, newParent)
    local value = tree(id)
    tree:remove_node(id)
    return tree:add_child(newParent, value)
end

return m
